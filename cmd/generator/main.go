package main

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path"
	"strings"
	"text/template"

	"github.com/matm/gocov-html/pkg/themes"
)

const tmpl = `// Code generated by "go run generator.go". DO NOT EDIT.

package themes

import (
	"text/template"
	"time"
)

func (t {{.Type}}) Data() *templateData {
	td:= &templateData{
		when:       time.Now().Format(time.RFC1123),
		projectURL: ProjectURL,
	}
	{{if .Style}}
	td.Style = "{{.Style}}"
	{{end}}
	{{if .Script}}
	td.script = "{{.Script}}"
	{{end}}
	return td
}

func (t {{.Type}}) Template() *template.Template {
	tmpl := {{.Template}}
	p := template.Must(template.New("theme").Parse(tmpl))
	return p
}
`

func inspect(p *params) error {
	fset := token.NewFileSet()
	token, err := parser.ParseFile(fset, p.filename, nil, parser.ParseComments)
	if err != nil {
		return err
	}
	ast.Inspect(token, func(n ast.Node) bool {
		fn, ok := n.(*ast.FuncDecl)
		if ok {
			p.rtype = fn.Recv.List[0].Type.(*ast.Ident).Name
			switch fn.Name.Name {
			case "Name":
				p.theme = fn.Body.List[0].(*ast.ReturnStmt).Results[0].(*ast.BasicLit).Value
				p.theme = strings.Replace(p.theme, `"`, "", -1)
			case "Assets":
				es := fn.Body.List[0].(*ast.ReturnStmt).Results[0].(*ast.CompositeLit).Elts
				for _, e := range es {
					kv := e.(*ast.KeyValueExpr)
					id := kv.Key.(*ast.Ident)
					switch id.Name {
					case "Stylesheets":
						elems := kv.Value.(*ast.CompositeLit).Elts
						for _, elem := range elems {
							sheet := elem.(*ast.BasicLit).Value
							p.assets.Stylesheets = append(p.assets.Stylesheets, strings.Replace(sheet, `"`, "", -1))
						}
					case "Index":
						tmplName := kv.Value.(*ast.BasicLit).Value
						p.assets.Index = strings.Replace(tmplName, `"`, "", -1)
					case "Scripts":
						elems := kv.Value.(*ast.CompositeLit).Elts
						for _, elem := range elems {
							script := elem.(*ast.BasicLit).Value
							p.assets.Scripts = append(p.assets.Scripts, strings.Replace(script, `"`, "", -1))
						}
					}
				}
			}
			return false
		}
		return true
	})
	return nil
}

func render(p *params) error {
	baseThemeDir := path.Join("..", "..", "themes", p.theme)
	out := strings.Replace(p.filename, ".go", "_gen.go", 1)
	outFile, err := os.Create(out)
	if err != nil {
		return err
	}
	defer outFile.Close()
	index, err := ioutil.ReadFile(path.Join(baseThemeDir, p.assets.Index))
	if err != nil {
		return err
	}
	// Contains all stylesheets' data.
	var allStyles bytes.Buffer
	// Contains all scripts' data.
	var allScripts bytes.Buffer

	type static struct {
		buf    *bytes.Buffer
		assets []string
	}

	for _, st := range []static{
		{&allStyles, p.assets.Stylesheets},
		{&allScripts, p.assets.Scripts},
	} {
		var buf bytes.Buffer
		for _, asset := range st.assets {
			f, err := os.Open(path.Join(baseThemeDir, asset))
			if err != nil {
				return err
			}
			defer f.Close()
			_, err = io.Copy(&buf, f)
			if err != nil {
				return err
			}
		}
		// Encode in base64 instead to prevent any invalid character escaping issues.
		fmt.Fprint(st.buf, base64.StdEncoding.EncodeToString(buf.Bytes()))
	}
	t, err := template.New("").Parse(tmpl)
	if err != nil {
		return err
	}
	type data struct {
		Script   string
		Style    string
		Template string
		Type     string
	}
	err = t.Execute(outFile, &data{
		Script:   allScripts.String(),
		Style:    allStyles.String(),
		Template: "`" + string(index) + "`",
		Type:     p.rtype,
	})
	return err
}

type params struct {
	filename string
	rtype    string // Receiver type.
	theme    string
	assets   themes.StaticAssets
}

func main() {
	name := os.Getenv("GOFILE")
	if name == "" {
		fmt.Println("Must be run by the \"go generate\" tool, like \"go generate ./...\"")
		os.Exit(1)
	}
	p := &params{filename: name}
	err := inspect(p)
	if err != nil {
		log.Fatal(err)
	}
	if err := render(p); err != nil {
		log.Fatal(err)
	}
}
